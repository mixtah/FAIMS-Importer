#!/usr/local/bin/python2.7
# encoding: utf-8
'''
 -- Converts FAIMS exported XML data into a format that can be ingested by Alveo


@author:     Michael Bauer

'''

import sys
import os
import json
import re, csv
import pyalveo
import subprocess
from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

DEBUG = 1
TESTRUN = 0
PROFILE = 0

BASE_URL = 'https://staging.alveo.edu.au/'
DOWNSAMPLED_FORMAT = 'wav' #This is just default: Can also be 'mp3'
DOWNSAMPLED_BITRATE = '16000'
DOWNSAMPLED_SAMPLERATE = '16000'

program_name = "FAIMS to Alveo Converter"

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg
    def __str__(self):
        return self.msg
    def __unicode__(self):
        return self.msg

def read_csv(input):
    ''' Reads the primary exported .csv file and returns the results as a dict '''
    with open(os.path.join(input,'Entity-Interview.csv'),'r') as csvfile:
        data = csv.DictReader(csvfile)
    return data

def process_data(input=None,apiKey=None,collection=None, verbose=False):
    
    client = pyalveo.Client(api_url=BASE_URL,api_key=apiKey,verifySSL=False)
    
    # TODO: check to see if we're able to modify the given collection (and that it exists)
    
    speaker_data = read_csv(input) #If we change the source (ie: xml, json, sqlite) make a new function
    
    try:
        for speaker in speaker_data:
            
            client.add_speaker(collection, speaker_data)
    except pyalveo.APIError, e:
        if e.http_status_code==403:
            print("Unable to ingest data: You do not have write access to the collection: "+collection)
            return 1
            
    return 0


def downsampleAudio(file,verbose=False):
    ''' Will convent an audio file to mp3 and downsample it to 16bit. File must be the full directory. '''
    stdout = stderr = None
    if verbose:
        stdout = stderr = sys.stdout
        
    dir = file.split(os.sep)[:-1]
    #convert file type
    process = subprocess.Popen('ffmpeg -i '+file+' -ar '+DOWNSAMPLED_SAMPLERATE+' -b:a '+DOWNSAMPLED_BITRATE+' '+dir+os.sep+'downsampled.'+DOWNSAMPLED_FORMAT,stdout=stdout,stderr=stderr)
    
    poll = None
    while poll==None:
        poll = process.poll()
    if poll>0:
        #An error occured. Probably bad file directory, codec or ffmpeg isn't found (path not configured or ffmpeg not downloaded).
        print("Unable to downsample "+file+'''. This may have occured due to a bad path or filename, 
                the file not existing, a bad audio encoding or due to an error with ffmpeg, 
                such as an improperly configured PATH variable or you may not have ffmpeg installed.\n
                For more details about this error, please run the process again with the --verbose (-v) parameter.''')
        return False
    
    return True

def main(argv=None): # IGNORE:C0111
    '''Command line options.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    try:
        # Setup argument parser
        parser = ArgumentParser(formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %(default)s]")
        parser.add_argument("-i", "--input", dest="input", help="The Root file to be Imported", metavar="path" )
        parser.add_argument("-k", "--apikey", dest="apikey", help="The API Key as Generated by Alveo. See https://app.alveo.edu.au/", metavar="path" )
        parser.add_argument("-c", "--collection", dest="collection", help="The collection this data will be added to. You must be a data_owner in order to add documents to a collection.", metavar="path" )

        # Process arguments
        args = parser.parse_args()

        if args.verbose > 0:
            verbose = True
        else:
            verbose = False
        
        return process_data(args.input, args.apikey, verbose)
    
    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    #except Exception, e:
    #    if DEBUG or TESTRUN:
    #        raise(e)
    #    indent = len(program_name) * " "
    #    sys.stderr.write(program_name + ": " + repr(e) + "\n")
    #    sys.stderr.write(indent + "  for help use --help")
    #    return 2

if __name__ == "__main__":
    if TESTRUN:
        import doctest
        doctest.testmod()
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = '_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
    sys.exit(main())